
#### 前端模块化开发的价值

AMD/CMD   ES6，Web Components

#### 为什么要用模块化的JavaScript

对前端而言，模块化并不像后端语言那样简单，它涉及到很多工程问题与历史包袱。

模块化编程解决了一系列的问题，包括： 

### 解决的问题：

- 命名冲突
    + seajs：通过exports 暴露接口，这意味着不需要全名空间，也不需要全局变量
- 文件依赖
    + 通过require引入依赖，让开发者只需要关心当前模块的依赖
- 性能优化
    + 通过异步加载模块


举个栗子：

    做项目时，常常会将一些通用的、底层的功能抽象出来，独立成一个个函数，比如...并把它封装到一个文件中，比较utils.js

    直到团队越来越大，项目越来越复杂，我们发现这种方式会有越来越多的问题：
    比如：
        1. 其它人可以也定义同名的函数，导致函数被覆盖，代码出现问题
        2. 由于之前的each方法只能用来遍历数组，而我现在想遍历对象，但是each方法已经定义，我只能定义一个eachObject方法
    
    由于种种的问题，不得不改变代码的编写方法，于是参照java的方式，引入命名空间：
        ...
    
    通过命名空间，虽然能够极大程度的缓解冲突的问题，但也有非常严重的问题，那就是命名空间过长，不方便记忆。


有没有更优雅的解决方式呢？这里先不说，我们来看看另外一个常见的问题：

文件依赖

我们还是基于utils.js开发UI组件，这样可以避免其它的同事重复造轮子。
假设我们这边开发了一个dialog组件，使用方式很简答，类似如果代码
...

先引入utils.js再引入dialog.js，然后再传入配置。

可是总有新同学会遇到一些错误，导致dialog.js无法正常工作，要么是utils.js没有在dialog.js之前引入，要么就完全没有引入utils.js,只引入了dialog.js导致报错。

上面这个例子的文件依赖还在可控范围内，当项目越来越复杂，从多文件之间的依赖会让人抓狂...
包括下面这些问题，可能很很多前端开发人员也会经常遇到：
...
这些问题都是由于文件依赖没有很好的管理起来. 在前端页面里,大部分的依赖目前依旧是通过人肉的方式保证，当团队比较小的时候，不会有什么问题，当团队越来越大，
公司的业务越来越复杂之后，依赖的问题如果不解决，就会成为一个大问题。

命名冲突和文件依赖，是前端开发过程中的两个经典问题。下来我们看如何通过模块化开发来解决。

#### 如何编写模块化的javascript











    






#### 

#### 异步模块规范

AMD 
    define( ['dep1', 'dep2'], function( dep1, dep2 ){
        return function(){};
    } );

CMD
    define( function( require, exports, module ){
        var dep1 = require('dep1');
        var dep2 = require('dep2');
    } )

CommonJs

##### 模块化加载器的实现

    https://www.zhihu.com/question/21157540
    
    - 模块化加载的原理
    - 模块依赖解析


##### 拥抱ES6

 - seajs已死

 - import / export
