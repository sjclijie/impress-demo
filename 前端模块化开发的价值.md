
#### 前端模块化开发的价值

AMD/CMD   ES6，Web Components

#### 为什么要用模块化的JavaScript

对前端而言，模块化并不像后端语言那样简单，它涉及到很多工程问题与历史包袱。

模块化编程解决了一系列的问题，包括： 

- 命名冲突
    + seajs，requirejs：通过exports 暴露接口，这意味着不需要全名空间，也不需要全局变量
- 文件依赖
    + 通过require引入依赖，让开发者只需要关心当前模块的依赖
- 性能优化
    + 通过异步加载模块


举个栗子：

    做项目时，常常会将一些通用的、底层的功能抽象出来，独立成一个个函数，比如...并把它封装到一个文件中，比较utils.js

    直到团队越来越大，项目越来越复杂，我们发现这种方式会有越来越多的问题：
    比如：
        1. 其它人可以也定义同名的函数，导致函数被覆盖，代码出现问题
        2. 由于之前的each方法只能用来遍历数组，而我现在想遍历对象，但是each方法已经定义，我只能定义一个eachObject方法
    
    由于种种的问题，不得不改变代码的编写方法，于是参照java的方式，引入命名空间：
        ...
    
    通过命名空间，虽然能够极大程度的缓解冲突的问题，但也有非常严重的问题，那就是命名空间过长，不方便记忆。


有没有更优雅的解决方式呢？这里先不说，我们来看看另外一个常见的问题：

文件依赖

我们还是基于utils.js开发UI组件，这样可以避免其它的同事重复造轮子。
假设我们这边开发了一个dialog组件，使用方式很简答，类似如果代码
...

先引入utils.js再引入dialog.js，然后再传入配置。

可是总有新同学会遇到一些错误，导致dialog.js无法正常工作，要么是utils.js没有在dialog.js之前引入，要么就完全没有引入utils.js,只引入了dialog.js导致报错。

上面这个例子的文件依赖还在可控范围内，当项目越来越复杂，从多文件之间的依赖会让人抓狂...
包括下面这些问题，可能很很多前端开发人员也会经常遇到：
...
这些问题都是由于文件依赖没有很好的管理起来. 在前端页面里,大部分的依赖目前依旧是通过人肉的方式保证，当团队比较小的时候，不会有什么问题，当团队越来越大，
业务越来越复杂之后，依赖的问题如果不解决，就会成为一个大问题。

这些问题都是前端开发中经常遇到的问题。下来我们看如何通过模块化开发来解决。



#### 如何编写模块化的javascript

seaJS 追求简单、自然的代码书写和组织方式，具有以下核心特性：

简单友好的模块定义规范：SeaJS 遵循CMD规范，可以像Node.js一般书编模块代码。
自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。

-
来看看上面的这两个例子中如果引入 SeaJS 该怎么写
首先是 util.js ，我们改用 SeaJS 的 CMD 规范来书写
...
可以看到，其实改变并不大，主要是外部包裹了一层，再加最后多写了一行
最后这行很重要，通过它，文件对外提供一个叫做 log 方法的接口
另外大家发现没，这里我没有使用命名空间，为什么呢？看下面的 component.js
...

首先是 var util = require('./util.js'); 通过这个函数，seajs可以直接加载js文件，并且这个函数同步的，这个函数的返回值就是utils.js文件里面的exports对像，所以下面我们就可以直接使用util.log()来调用utils提供的对外接口了。

相信我们已经看到了使用seajs带来的好处：
1. 通过exports暴露接口，这意味着不需要全名空间，更不需要全局变量，这是一种彻底解决命名冲突的方案
2. 通过require自动引入依赖，让依赖内置，我们只需要关心当前模块的依赖，其它的事情都会自动被处理。

当然 还有基于adm的requirejs可以选择，使用方法跟seajs差不太多，大家灵活选择。

#### AMD & CMD & Commonjs

amd和cmd都是一种如何定义和如何去加载模块的一种规范，

amd是推广requirejs的时候出现的一个规范
cmd是推广seajs的时候出来的一个犯规

这些规范的目的都是为了javascript的模块化开发，特别是在浏览器端。并且这些规范的实现都达到了在浏览器端模块化开发的目的。

CMD：在代码运行的时候，是不知道依赖的，需要遍历所有的require关键字，找出依赖，具体的做法是将function toString后用正则匹配出依赖。  显然牺牲了一部分的性能。但是开发更方便。

AMD: 在代码运行的时候，立即就能知道依赖，不用遍历整个函数体就可以找到依赖，它的缺点就是我们必须显式指明依赖，写代码写了几百行，发现需要增加一个依赖，你需要返回顶部将依赖添加进数组。


再来看看CommonJS:

CommonJS是一个志愿性质的工作组，它致力于设计、规划并标准化 JavaScript API。
相对AMD和cmd, 它的覆盖更宽泛的方面比如 IO、文件系统、promise 模式等等。

...

从结构上角度上来讲，一个commonjs模块是一段可重用的javascript, 它可以导出一系列的对象给依赖它的代码用。（这样的模块外围没有define函数包裹）

从高一点的层次上来说，它主要包含两部分，
一个是exports变量，它包含着模块希望提供给其它模块使用的对象。
一个是require函数，用来导入其它模块。

exports的基本用法：
...

CJS适用于浏览器吗？
有些开发者觉得Commonjs更适合服务端开发，因为很多面向服务端的特性比如io, system, file 就因为浏览器的特性无法使用。

尽管如此，我们还是有办法让cjs模块运行在浏览器上的， 比如browserify, 它可以将cjs模块通过预编译的方式运行于浏览器
另外一种选择就是webpack, 通过loader的方式来翻译代码，让其在浏览器中运行。


##### 模块化加载器的实现

我们这边先不考虑模块定义的各种规范，只是简单的分析一下加载的原理，实现一个最小化的加载器。

既然是模块化加载，拿到模块内容当然是最主要的部分，不管是css还是js，通过script或者link标签就能够搞定。我们看一下代码：

...

为什么不采用ajax呢，主要是因为有跨域的问题，因为js文件一般都放在cdn上面，通过ajax的话显然无法获取到内容。

那第二步就是要解析模块之间的依赖关系：
假如我们有这么一个工程：
...
我们看到它的依赖是这样的：
a.js依赖b.js
index.html依赖a.js和c.js

我们在首页中通过require加载模块，怎么能够知道要加载哪先模块呢？
通过toString() + regexp提取。

通过以上的代码我们就已经知道了模块化加载器是如何实现的，但我们写的这几行代码还是不可用的，
因为目前还存在的许多问题：

1. 事件机制：
    我们当前并没有为模块添加事件，我们知道由于浏览器天生异步的特性，对于script标签加载js，我们无法判断是否加载完毕，这样就必须为先script节点绑定相应的事件, 然后添加进dom树，开始加载过程。

2. 依赖处理的并不完美，因为实际开发过程中很有可能出现循环依赖的情况，比如a依赖b和c, b依赖a和c，这样ab就循环依赖了。

那大家如果对这块有兴趣，可以继续深入研究一下，


###### 拥抱ES6

很多同学可能觉得ECMAScript 6 还离我们很遥远，实际上在2015年，ec6就已经正式发布，虽然浏览器还只只支持一小部分特性，但node.js4.0以上的版本已经支持大部分的ec6特性。

比如
    class,   再也不需要使用CoffeeScript的语法糖写类了
    generators生成器 配置co模块可以很方便实现高异步流程控制，避免回调黑洞
    collection  各种集合，映射等...
    arrow function 箭头函数
    template string 模板字符串
    import / export 模块的导入和导出

那今天我们主要关注的就是import和export 

导出：
可以直接在任何变量或者函数前面加上一个 export 关键字，就可以将它导出，写法非常简洁

导入：
...

那你可能会注意到一个奇怪的语法，import {} ...
实际上这也是es6中新增的语法，叫做结构赋值，所以我们上面的例子还可以写成这样...

默认导出：
大家会发现上面的写法比较麻烦，因为必须要指定一个名字。其实很多时候一个模块只导出了一个变量，根本没必要指定一个名字。 所以还有一种方法叫做默认导出，就是指定一个变量作为默认值导出
。。。

所以导入的时候不用写 import {myFunc} from './myFunc.js'


...


总结 ：
    那今天的内容就这些，我觉得前端发展的速度是非常快的，尤其是这两年，各种各样的新东西非常多，包括node.js这块也有很多的东西值得我们去学习，感觉做前端还是挺辛苦的。然后大家加油吧。































    






#### 

#### 异步模块规范

AMD 
    define( ['dep1', 'dep2'], function( dep1, dep2 ){
        return function(){};
    } );

CMD
    define( function( require, exports, module ){
        var dep1 = require('dep1');
        var dep2 = require('dep2');
    } )

CommonJs

##### 模块化加载器的实现

    https://www.zhihu.com/question/21157540
    
    - 模块化加载的原理
    - 模块依赖解析


##### 拥抱ES6

 - seajs已死

 - import / export
