
#### 前端模块化开发的价值

AMD/CMD   ES6，Web Components

#### 为什么要用模块化的JavaScript

对前端而言，模块化并不像后端语言那样简单，它涉及到很多工程问题与历史包袱。

模块化编程解决了一系列的问题，包括： 

### 解决的问题：

- 命名冲突
    + seajs：通过exports 暴露接口，这意味着不需要全名空间，也不需要全局变量
- 文件依赖
    + 通过require引入依赖，让开发者只需要关心当前模块的依赖
- 性能优化
    + 通过异步加载模块


举个栗子：

    做项目时，常常会将一些通用的、底层的功能抽象出来，独立成一个个函数，比如...并把它封装到一个文件中，比较utils.js

    直到团队越来越大，项目越来越复杂，我们发现这种方式会有越来越多的问题：
    比如：
        1. 其它人可以也定义同名的函数，导致函数被覆盖，代码出现问题
        2. 由于之前的each方法只能用来遍历数组，而我现在想遍历对象，但是each方法已经定义，我只能定义一个eachObject方法
    
    由于种种的问题，不得不改变代码的编写方法，于是参照java的方式，引入命名空间：
        ...
    
    通过命名空间，虽然能够极大程度的缓解冲突的问题，但也有非常严重的问题，那就是命名空间过长，不方便记忆。


有没有更优雅的解决方式呢？这里先不说，我们来看看另外一个常见的问题：

文件依赖

我们还是基于utils.js开发UI组件，这样可以避免其它的同事重复造轮子。
假设我们这边开发了一个dialog组件，使用方式很简答，类似如果代码
...

先引入utils.js再引入dialog.js，然后再传入配置。

可是总有新同学会遇到一些错误，导致dialog.js无法正常工作，要么是utils.js没有在dialog.js之前引入，要么就完全没有引入utils.js,只引入了dialog.js导致报错。

上面这个例子的文件依赖还在可控范围内，当项目越来越复杂，从多文件之间的依赖会让人抓狂...
包括下面这些问题，可能很很多前端开发人员也会经常遇到：
...
这些问题都是由于文件依赖没有很好的管理起来. 在前端页面里,大部分的依赖目前依旧是通过人肉的方式保证，当团队比较小的时候，不会有什么问题，当团队越来越大，
公司的业务越来越复杂之后，依赖的问题如果不解决，就会成为一个大问题。

命名冲突和文件依赖，是前端开发过程中的两个经典问题。下来我们看如何通过模块化开发来解决。

#### 如何编写模块化的javascript

seaJS 追求简单、自然的代码书写和组织方式，具有以下核心特性：

简单友好的模块定义规范：SeaJS 遵循CMD规范，可以像Node.js一般书写模块代码。
自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。

-
来看看上面的这两个例子中如果引入 SeaJS 该怎么写
首先是 util.js ，我们改用 SeaJS 的 CMD 规范来书写
...
可以看到，其实改变并不大，主要是外部包裹了一层，再加最后多写了一行
最后这行很重要，通过它，文件对外提供一个叫做 print 方法的接口
另外大家发现没，这里我没有使用命名空间，为什么呢？看下面的 component.js
...

首先是 var util = require('./util.js'); 通过这个函数，seajs可以直接加载js文件，并且这个函数同步的，这个函数的返回值就是utils.js文件里面的exports对像，所以下面我们就可以直接使用util.log()来调用utils提供的对外接口了。

相信我们已经看到了使用seajs带来的好处：
1. 通过exports暴露接口，这意味着不需要全名空间，更不需要全局变量，这是一种彻底解决命名冲突的方案
2. 通过require自动引入依赖，让依赖内置，我们只需要关心当前模块的依赖，其它的事情都会自动被处理。


#### AMD & CMD 

amd和cmd都是一种如何定义和如何去加载模块的一种规范，

amd是推广requirejs的时候出现的一个规范
cmd是推广seajs的时候出来的一个犯规

这些规范的目的都是为了javascript的模块化开发，特别是在浏览器端。并且这些规范的实现都达成在浏览器端模块化开发的目的。

CMD：在代码运行的时候，是不知道依赖的，需要遍历所有的require关键字，找出依赖，具体的做法是将function toString后用正则匹配出依赖。  显然牺牲了一部分的性能。但是开发更方便。

AMD: 在代码运行的时候，立即就能知道依赖，不用遍历整个函数体就可以找到依赖，它的缺点就是我们必须显式指明依赖，写代码写了几百行，发现需要增加一个依赖，你需要返回顶部将依赖添加进数组。

##### 模块化加载器的实现

我们这边先不考虑模块定义的各种规范，只是简单的分析一下加载的原理，实现一个最小化的加载器。

既然是模块化加载，拿到模块内容当然是最主要的部分，不管是css还是js，通过script或者link标签就能够搞定。我们看一下代码：

...

为什么不采用ajax呢，主要是因为有跨域的问题，因为js文件一般都放在cdn上面，通过ajax的话显然无法获取到内容。

那第二步就是要解析模块之间的依赖关系：
假如我们有这么一个工程：
...
我们看到它的依赖是这样的：
a.js依赖b.js
index.html依赖a.js和c.js

我们在首页中通过require加载模块，怎么能够知道要加载哪先模块呢？
通过toString() + regexp提取。

通过以上的代码我们就已经知道了模块化加载器是如何实现的，但我们写的这几行代码还是不可用的，
因为目前还存在的许多问题：

1. 事件机制：
    我们当前并没有为模块添加事件，我们知道由于浏览器天生异步的特性，对于script标签加载js，我们无法判断是否加载完毕，这样就必须为先script节点绑定相应的事件, 然后添加进dom树，开始加载过程。

2. 依赖处理的并不完美，因为实际开发过程中很有可能出现循环依赖的情况，比如a依赖b和c, b依赖a和c，这样ab就循环依赖了。

那大家如果对这块有兴趣，可以继续深入研究一下。



















    






#### 

#### 异步模块规范

AMD 
    define( ['dep1', 'dep2'], function( dep1, dep2 ){
        return function(){};
    } );

CMD
    define( function( require, exports, module ){
        var dep1 = require('dep1');
        var dep2 = require('dep2');
    } )

CommonJs

##### 模块化加载器的实现

    https://www.zhihu.com/question/21157540
    
    - 模块化加载的原理
    - 模块依赖解析


##### 拥抱ES6

 - seajs已死

 - import / export
